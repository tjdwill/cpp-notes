# Signals and Slots

In Qt, `QObject`s can communicate using the signals and slots mechanism. As the
result of some interesting state change, a given object can emit a signal
(potentially with data attached) for other objects to respond to. It's important
to note that a `QObject` neither knows or cares what entities are subscribed to
its signals. It simply reports a state change. Since they are generated by the
meta-object compiler (moc), users are not responsible for defining signals and,
in fact, should refrain from attempting to do so.

Slots are class methods that receive signals and perform some action sequence in
response. Like with signals, `QObject`s with slots are unaware if they are
connected to a signal. In terms of implementation, slots are simply class
methods and can be invoked as such. 

## Connecting Slots and Signals

To establish an association between a signal and slot (or between two signals),
we use the `QObject::connect` static method. The basic format is:

```c++
QObject::connect(
    <SENDER pointer>, <Signal Function>,
    <RECIPIENT pointer>, <Slot Function>
)
``` 

Before C++11 and Qt5, connections were specified using special `SIGNAL` and
`SLOT` macros that produces strings of the function signatures. While this
method still works, it is flawed in that it does not allow for compile-time
analysis. As a result, it is possible to connect a signal-slot pair with
conflicting signatures. **NOTE**: as I mention signatures, it is important to
realize that a signal and slot pair do not have to have *equivalent* function
signatures. Instead, the signal's signature must at least have all of the
parameter types in the slot signature. As a programming rule, I would ensure my
slots' parameters are declared in the same order as the signal it's associating
with.

Now, however, to specify a signal or slot function, we use function addresses:

```cpp
// example call
QObject::connect(foo, &QPushButton::clicked():, bar, &CustomObject::baz)


// overloaded method specification
QObject::connect(
    slider, qOverload<int>(&QSlider::valueChanged),
    spin_box, &QSpinBox::setValue
);
```

Since methods can be overloaded, we specify the specific method use the
templated `qOverload`. I believe it's a valid method for C++14 and above. If not
using those compatible versions, you may have to use the more direct
`QOverload<T>::of` approach (notice the capitalization). In emergencies, you can
use `static_cast`.


[Read more about the connection syntax
here.](https://wiki.qt.io/New_Signal_Slot_Syntax#Missing_Q_OBJECT_in_class_definition)

## Requirements

Some people make custom classes to interact with the Qt framework. To do so via
signals and slots, you must specify the `Q_OBJECT` macro at the top of your
class definition. Then, you specify signals and slots using their eponymous
keywords:

```cpp

class Foo: public QObject
{
    Q_OBJECT

    public:

    public slots:  // can also specify private slots (and protected?).
        void setFooValue(int fooValue);

    signals:

    private:

}
```

